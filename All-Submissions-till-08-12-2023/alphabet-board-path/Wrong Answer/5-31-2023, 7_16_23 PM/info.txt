{"id":960968414,"lang":"cpp","lang_name":"C++","time":"6 months, 1 week","timestamp":1685540783,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/960968414/","is_pending":"Not Pending","title":"Alphabet Board Path","memory":"N/A","code":"class Solution {\npublic:\n    void constructPath(int idx,string target,int i,int j,string& path,unordered_map<char,pair<int,int>>& board){\n        if(idx>target.size()-1)\n        return;\n        int trow=board[target[idx]].first,tcol=board[target[idx]].second,diff_row=abs(trow-i),diff_col=abs(tcol-j);\n        if(trow<i)\n        path+=(string(diff_row,'U'));\n        if(trow>i)\n        path+=(string(diff_row,'D'));\n        if(tcol<j)\n        path+=(string(diff_col,'L'));\n        if(tcol>j)\n        path+=(string(diff_col,'R'));\n        // handling the wrong index\n        // I am basically forcing the fn. to travel to 'u' first and then go I row down\n        // this ensures that the fn. does not travel through the invalid indices of row 5\n        if(target[idx]=='z'){\n            path+='D';\n            trow=5; \n        }\n        path+='!';\n        constructPath(idx+1,target,trow,tcol,path,board);\n    }\n    string alphabetBoardPath(string target) {\n        string path=\"\";\n        unordered_map<char,pair<int,int>> board;\n        board['z']={4,0}; \n        // wrong index that will be handled later (because row 5 does not fully exist)\n        char c='a';\n        for(int i=0;i<5;i++)\n        for(int j=0;j<5;j++)\n        board[c++]={i,j};\n        constructPath(0,target,0,0,path,board);\n        return(path);\n    }\n};","compare_result":"1111111111111111111111111111011100011100011100011000111111111","title_slug":"alphabet-board-path","has_notes":false,"flag_type":1}