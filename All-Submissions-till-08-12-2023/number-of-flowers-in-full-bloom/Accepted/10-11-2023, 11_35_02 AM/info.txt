{"id":1072406566,"lang":"cpp","lang_name":"C++","time":"1 month, 3 weeks","timestamp":1697004302,"status":10,"status_display":"Accepted","runtime":"305 ms","url":"/submissions/detail/1072406566/","is_pending":"Not Pending","title":"Number of Flowers in Full Bloom","memory":"90 MB","code":"class Solution {\npublic:\n    vector<int> fullBloomFlowers(vector<vector<int>>& flowers, vector<int>& people) {\n        sort(flowers.begin(),flowers.end());\n        // Need to return answer in order therefore, we will preserve vector\n        vector<int> sortedPeople(people.begin(),people.end()),answer;\n        sort(sortedPeople.begin(),sortedPeople.end());\n        // Creating a min heap to store the minimum end time at top\n        priority_queue<int,vector<int>,greater<int>> minHeap;\n        // Unordered Map to map people to no. of flowers\n        unordered_map<int,int> visibleFlowers;\n        int i=0,f=flowers.size();\n        for(int arrivalTime:sortedPeople) {\n            while(i<f && flowers[i][0]<=arrivalTime) {\n                minHeap.push(flowers[i][1]);\n                i++;\n            }\n            // removing flowers that will stop blooming before arrivalTime\n            while(!minHeap.empty() && minHeap.top()<arrivalTime) minHeap.pop();\n            // no. of flower visible for the person who arrives at arrivalTime\n            visibleFlowers[arrivalTime]=minHeap.size();\n        }\n        // Creating answer in proper order\n        for(int person:people) answer.push_back(visibleFlowers[person]);\n        return answer;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111","title_slug":"number-of-flowers-in-full-bloom","has_notes":false,"flag_type":1}