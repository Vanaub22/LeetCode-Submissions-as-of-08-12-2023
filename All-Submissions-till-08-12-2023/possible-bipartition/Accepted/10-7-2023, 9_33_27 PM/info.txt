{"id":1069434908,"lang":"cpp","lang_name":"C++","time":"2Â months","timestamp":1696694607,"status":10,"status_display":"Accepted","runtime":"168 ms","url":"/submissions/detail/1069434908/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"71.2 MB","code":"class Solution {\npublic:\n    bool dfs_colour_check(int start, int colour, int colours[], vector<int> adj[]) {\n        colours[start]=colour;\n        for(int i:adj[start]) {\n            if(colours[i]==-1) {\n                if(!dfs_colour_check(i,!colour,colours,adj)) return false;\n            }\n            else if(colours[i]==colour) return false;\n        }\n        return true;\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        // We will convert this into a graph and check if it is Bi-Partite\n        // Dislikes will be edges and people will be nodes\n        // Bi-directional OR Undirected Graph will be used\n        // this is because if a hates b OR vice-versa, a cannot be put into the same group as b\n        vector<int> adj[n+1];\n        for(auto dislike:dislikes) {\n            adj[dislike[0]].push_back(dislike[1]);\n            adj[dislike[1]].push_back(dislike[0]);\n        }\n        int colours[n+1];\n        memset(colours,-1,sizeof(colours)); // -1 => not coloured (we have 2 colours 0 and 1)\n        for(int i=1;i<=n;i++) {\n            if(colours[i]==-1) {\n                if(!dfs_colour_check(i,0,colours,adj)) return false;\n            }\n        }\n        return true;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition","has_notes":false,"flag_type":1}