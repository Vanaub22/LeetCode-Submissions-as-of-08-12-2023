{"id":1084422056,"lang":"cpp","lang_name":"C++","time":"1 month, 1 week","timestamp":1698304231,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1084422056/","is_pending":"Not Pending","title":"Most Frequent Subtree Sum","memory":"25.1 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> findFrequentTreeSum(TreeNode* root) {\n        vector<int> freqtreeSums;\n        unordered_map<int,int> subtreeSumFreq; // To store frequencies of subtree sums\n        dfs(root,subtreeSumFreq); // Calculating subtree sum frequencies\n        // Determining the maximum frequency subtree sums\n        int maxFreq=-1;\n        for(auto& sumFreq:subtreeSumFreq) {\n            if(maxFreq<=sumFreq.second) {\n                if(maxFreq<sumFreq.second) {\n                    maxFreq=sumFreq.second;\n                    freqtreeSums.clear();\n                }\n                freqtreeSums.emplace_back(sumFreq.first);\n            }\n        }\n        return freqtreeSums;\n    }\n    // Helper function for calculating subtree sum\n    int subtreeSum(TreeNode* root) {\n        return root?root->val+subtreeSum(root->left)+subtreeSum(root->right):0;\n    }\n    // Helper function for calculating frequency of subtree sums\n    void dfs(TreeNode* root, unordered_map<int,int>& subtreeSumFreq) {\n        if(!root) return;\n        subtreeSumFreq[subtreeSum(root)]++;\n        dfs(root->left,subtreeSumFreq);\n        dfs(root->right,subtreeSumFreq);\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"most-frequent-subtree-sum","has_notes":false,"flag_type":1}